\section{Future work}
In this section, we will discuss the future directions and improvements to our current prototype that we are willing to pursue in future.

\subsection{End-to-end web application debloating}
In this work, we show that web application debloating has the potential to significantly reduce the attack surface. Nevertheless, it comes with a set of challenges.

\subsubsection{Handling calls to removed code}
One of the biggest challenges of using debloating in production applications is handling calls to removed functions. In our current implementation, upon executing a function that leads to debloated code, user's operation is terminated. Then the user is notified that the intended functionality has been removed. This can happen after clicking on a link, or after several steps into filling a multi-step form. To make this more user friendly and enable website administrators to make the final decision, we envision several improvements:
\begin{itemize}
  \item Adding the functionality to dynamically introduce back the removed code. This decision can be made either through an administration panel, or after a second factor of authentication for privileged users. For that, we need to identify risky actions and
  enforce further security mechanisms and identity verification steps before continuing. From another point of view, this step can be seen as an anomaly detection system based on history of the user behavior.
  \item Our current hypothesis is based on the observation that not all users of an application require all features. To go one step further, one can pursue, user and role based debloating. Under this scenario, different set of users for the same web application are provided with their own debloated versions based on their activity history.
\end{itemize}

\subsubsection{Propagating debloating changes to the UI}
To further improve the usability of debloated applications, we propose a system that would reflect debloated functionalities in the UI of web applications. By tracking web application UI elements back to their implementation and doing a backward traversal on the call graph, we can build this dependency chain and disable, limit functionality or add informative messages to UI elements. This will inform the users about the disabled features before investing any time and effort on that function.

\subsubsection{Crowdsourcing code coverage collection}
By shipping the code coverage collection infrastructure to real world users and website owners, we gain an insight into how the applications are used by different types of users. To make code coverage recording less resouce intensive, we need to know the source of this overhead.
Our toolset is built on top of XDebug PHP extension. To collect line level code coverage, XDebug hooks into various PHP opcodes. This makes the program execution slower and more resource intensive. Meanwhile, we only need function coverage information in our setup. This information can either be collected by a light-weight code profiler that is optimized for this task, or by developing and including PHP libraries in web applications that collect execution traces from call stack. To that end, we plan to develop optimized code profilers that can be easily installed and integrated with web applications without the need to enable PHP extensions and undergoing significant performance hits. Furtheremore, by relying on function coverage instead of line coverage, our code coverage information will be more resilient to small changes that affect the order of source line numbers.
